#!/usr/bin/python2.4
##
## This file is part of CDS Invenio.
## Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008 CERN.
##
## CDS Invenio is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## CDS Invenio is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with CDS Invenio; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

"""
Batch editing tool for updating many records at once.

Run with --help option to get usage information.
"""


import os, sys
import optparse
import tempfile, urllib
import shutil, difflib
from xml.dom import minidom  
if sys.version_info[1] >= 4:
    import subprocess
else:
    sys.stderr.write(sys.argv[0] + " requires Python >= 2.4\n")
    sys.exit(187)

import invenio.config


def minimize_document(filename, fieldname):
    """Process the DOM of the downloaded MARC XML so that much less remains

    Strip the file back to a <collection> of <records> each with its <controlfield>
    and the <datafield>s whose tag attributes match 'fieldname'.

    @param filename - the MARC XML file to process
    @param fieldname - the MARC field (e.g., 700, 999, 250) to be filtered on
    @returns a string representing the reduced XML
    """
    dom = minidom.parse(filename)
    if dom.documentElement.tagName != "collection":
        error("""I failed at filtering the XML document; it doesn't appear to be a MARC XML
collection.  Did the document search URL correctly specify '&of=xm' ?""")
    
    remove_queue = []
    for record in dom.documentElement.getElementsByTagName('record'):
        for field in record.childNodes:
            if field.nodeName == 'datafield' and field.getAttribute('tag') == fieldname:
                continue
            elif field.nodeName == 'controlfield':
                continue
            else:
                remove_queue.append(field)
    for node in remove_queue:
        record = node.parentNode
        record.removeChild(node)
    return dom

def error(msg, p=None, xval=1):
    sys.stderr.write(msg+'\n\n')
    if p != None: sys.stderr.write(p.format_help())
    sys.exit(xval)

def warning(msg):
    sys.stderr.write(msg+'\n')

def pick_an_editor_or_die():
    """Look for one of the standard editors; return its path if found.

    If none of the standard editors is in the user's path, explain what 
    happened and exit.
    """
    warning("""Environment variable EDITOR unset; please set EDITOR when using %s.
Falling back (in this order) to one of:
* joe
* pico
* emacs
* vi""")
    if not os.environ.has_key('PATH') or os.environ['PATH'] == '':
        p = os.defpath
    else:
        p = os.environ['PATH']
    for dir in p.split(os.pathsep):
        for ed in ['joe', 'pico', 'emacs', 'vi']:
            edex = os.path.join(dir, ed)
            if os.access(edex, os.X_OK):
                return edex
    error("""None of the standard editors was found on your system path.
Please correct your environment configuration and try again.""")

def command_line_parser():
    """Configure command line option parsing and return (options, arguments) tuple
    """
    parser = optparse.OptionParser(usage="%prog <[options]> [search string]")
    tricky = optparse.OptionGroup(parser, "Tricky Options",
             "These options can be tricky to use correctly; please read the documentation carefully.")
    tricky.add_option('-a', '--add', dest='afield_tag', metavar='field_tag', default=None, 
                      help='Add a field of type [field_tag].  field_tag must be a MARC ' +
                      'field identifier.  For example, 700 for an author, or 999 for a reference.')
    tricky.add_option('-c', '--correct', dest='cfield_tag', metavar='field_tag', default=None, 
                      help='Add a field of type [field_tag].  field_tag must be a MARC ' +
                      'field identifier.  For example, 700 for an author, or 999 for a reference.')
    parser.add_option_group(tricky)
    opts, args = parser.parse_args()
    return parser, opts, args


if __name__ == "__main__":
    parser, opts, args = command_line_parser()

    if len(args) == 1:
        search_url = args[0]
    else:
        error("""[search string] is required.  Please perform an Invenio search to find the
documents to modify, and cut-and-paste that URL to this command-line.""", parser)

    if 'EDITOR' in os.environ:
        editor = os.environ['EDITOR']
    else:
        editor = pick_an_editor_or_die()

    fd, tmpfile = tempfile.mkstemp('.xm', 'invenio', '/tmp')
    os.close(fd)
    fd, tmpfile2 = tempfile.mkstemp('.xm', 'invenio', '/tmp')
    os.close(fd)

    if opts.afield_tag == None and opts.cfield_tag == None:
        urllib.urlretrieve(search_url, tmpfile)
    else:
        field = opts.afield_tag or opts.cfield_tag
        original_marc = urllib.urlopen(search_url)
        fragment = minimize_document(original_marc, field)
        out = open(tmpfile, 'w')
        out.writelines(fragment.toxml())
        out.close()
    # FIXME: if -a, we should parse the data down to just the field asked for and its children, and replace all of the text in them with dummy values

    shutil.copy(tmpfile, tmpfile2)
    retcode = subprocess.call([editor, tmpfile])
    if retcode:
        error("""Editing process returned error %s; batch edit incomplete.
To finish the process, resolve your editor difficulties, edit %s, and then
manually use 'bibupload' to submit the modified record.  To nullify
this set of edits, simply do nothing.""" % (str(retcode), tmpfile) )

    if len(list(difflib.unified_diff(open(tmpfile).readlines(), 
                                     open(tmpfile2).readlines()))) == 0:
        print "OK; batch file unmodified.  No changes submitted."
        os.remove(tmpfile)
        os.remove(tmpfile2)
        sys.exit(0)

    retcode = subprocess.call(['/usr/bin/xmllint', '--noout', tmpfile])
    if retcode:
        error("""xmllint returned errors on the file %s.  Please check to make sure
all tags are balanced and that every record has a controlfield element.  Then 
call bibupload manually.""" % tmpfile)

    if opts.afield_tag:
        retcode = subprocess.call([invenio.config.CFG_BINDIR+os.path.sep+"bibupload", "-a", tmpfile])
    elif opts.cfield_tag:
        retcode = subprocess.call([invenio.config.CFG_BINDIR+os.path.sep+"bibupload", "-c", tmpfile])
    else:
        retcode = subprocess.call([invenio.config.CFG_BINDIR+os.path.sep+"bibupload", "-r", tmpfile])
    if retcode:
        error("""bibupload returned error code %s.  Something is awry.
You should check the record on the website after indexing has run to make sure
nothing is wrong with it.  Check the Invenio Admin Guide for help comparing 
document revision histories.""" % retcode)

    print "OK; these documents should be updated in the next index period."
    #os.remove(tmpfile)
    #os.remove(tmpfile2)
    #sys.exit(0)
